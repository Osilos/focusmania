<!DOCTYPE html>
<html>
<head>
<title>transition-guide</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
</head>
<body>
<h1 id="transition-guide-from-tobii-eyex-framework-1-7-to-tobii-eyetracking-framework-2-0-for-unity">Transition Guide from Tobii EyeX Framework 1.7 to Tobii EyeTracking Framework 2.0 for Unity</h1>
<p>This document gives an overview of what is new in the Tobii EyeTracking Framework 2.0 compared to the Tobii EyeX Framework 1.7 (which is the latest 1.x version available on <a href="http://developer.tobii.com">http://developer.tobii.com</a>) and what needs to be considered when switching from 1.7 to 2.0.</p>
<p>Remember to also read the documentation included in the 2.0 SDK package: the Manual and the Scripting Reference.</p>
<h3 id="namespace-tobii-eyetracking-">Namespace <code>Tobii.EyeTracking</code></h3>
<p>In 1.7 all classes are prefixed with &quot;EyeX&quot;. In 2.0 all prefixes have been removed, and we have introduced a namespace so all clients need to add <code>using Tobii.EyeTracking;</code> to access the API.</p>
<p>All references to the <code>Tobii.EyeX.Client</code> and <code>Tobii.EyeX.Framework</code> namespaces have been removed from the API, meaning that <code>Tobii.EyeTracking</code> is the only namespace needed.</p>
<h3 id="quick-api-access-via-static-class-eyetracking-">Quick API access via static class <code>EyeTracking</code></h3>
<p>The 2.0 framework introduces a new quick and easy access to the most commonly used functionality via a static class called <code>EyeTracking</code>.<br>Here are some examples of static methods on the class:</p>
<ul>
<li><code>EyeTracking.GetGazePoint()</code></li><li><code>EyeTracking.GetUserPresence()</code></li><li><code>EyeTracking.GetFocusedObject()</code></li></ul>
<p>The static API uses lazy initialization and sets things up as they are first requested. This means that there will be some frames of invalid data after the first call to <code>EyeTracking.GetGazePoint()</code> before the data stream is up and running. The static API can be explicitly initialized using <code>EyeTracking.Initialize()</code>. This way the initialization period of invalid data can be moved to for example the startup sequence of the game instead of at the first request of data.</p>
<h3 id="gaze-focus">Gaze Focus</h3>
<p>The 1.7 framework relies entirely on the underlying Tobii EyeX Interaction Engine to calculate which objects the user is looking at. In the 2.0 framework we decided to do all calculations client-side to decide which game object the user is looking at. This way we can use algorithms that are more suitable for the Unity Engine&#39;s way of representing objects. </p>
<p>The concept introduced in 2.0 for this is <code>Gaze Focus</code>. An object that has Gaze Focus is considered to be intentionally focused by the user. The idea is that we will refine the algorithms continually in future versions of the framework, and that they will work in a good way for different eye tracker models with different characteristics in accuracy and precision, but also over a broad set of different eye-gaze characteristics of end-users. </p>
<p>As a developer you should use <code>Gaze Focus</code> as it is out-of-the-box, since an additional filtering done on top of the gaze focus calculation might be a bad fit when the algorithms change in a future release. Highlighting of objects and visualisations should use timings related to human perception rather than be adapted to a specific gaze focus algorithm, eye tracker model or a user&#39;s characteristic gaze-tracking.</p>
<p><code>Gaze Focus</code> is only available for 3D and 2D game objects. It does not work with UI elements.</p>
<h4 id="gazeaware-component">GazeAware component</h4>
<p>The GazeAware component has changed somewhat in the 2.0 framework:</p>
<ul>
<li>Its new name is <code>GazeAware</code> (with no <code>Component</code> suffix)</li><li>Its property is called <code>HasGazeFocus</code> (previously <code>HasGaze</code>)</li><li>There are no settings in the component (there used to be a settable property called <code>Delay Time</code>)</li></ul>
<h4 id="focused-object">Focused Object</h4>
<p>In addition to each <code>GazeAware</code> game object being able to read its state of <code>HasGazeFocus</code> in the <code>Update</code> function, it is also possible to ask the gaze focus handler which object is currently focused using the static function <code>EyeTracking.GetFocusedObject()</code>. This function returns only one object (or a null object).</p>
<h4 id="gaze-focus-settings">Gaze Focus Settings</h4>
<p>The gaze focus algorithms use a couple of configurable settings in their calculations:</p>
<ul>
<li>Maximum Distance: the maximum distance to detect gaze focus on</li><li>Layer Mask: the Unity layers to detect gaze focus on</li></ul>
<p>The settings are global and used for all GazeAware component instances. They are readonly in standalone builds and configurable only in the Unity Editor in the Eye Tracking Settings window found under Edit/Eye Tracking Settings...</p>
<h3 id="states">States</h3>
<p>A new interface <code>IStateValue</code> has been introduced and all state value types have been changes to types defined in the Tobii EyeTracking Framework or in the <code>UnityEngine</code>.</p>
<h3 id="changed-functionality">Changed Functionality</h3>
<h4 id="removed-components">Removed Components</h4>
<p>The Activatable and Pannable components have been removed together with all components for data and state access. Gaze Point data, and the User Presence and Gaze Tracking states are easily accessable via the static EyeTracking API instead.</p>
<p>We suggest using the GazeAware component with suitable key hooks instead of the Activatable component. Instead of the Pannable component take a look at different flavors of Infinite Screen provided in the Tobii Interaction Samples (soon available).</p>
<h4 id="removed-interactor-concept">Removed Interactor Concept</h4>
<p>It is no longer possible to programmatically define axis aligned rectangles as interactors using the API. The new gaze focus system only works with 3D and 2D game objects.</p>
<h4 id="data-streams">Data Streams</h4>
<p>The 2.0 framework only provides lightly filtered Gaze Point data. This has been done in preparation for some expected future changes in how the framework itself will retrieve data from the eye tracker where the previous data modes will not be available and therefore should not be exposed in the API.</p>
<p>The Eye Positions data stream has been marked as experimental. This is partly because we have not been able to implement any recommended good-enough user experience based on this data, and partly because we are expecting breaking changes to the format of this data.</p>
<p>The Fixations data stream has been removed because of expected future changes to what is provided from the underlying system.</p>
<h5 id="start-stop-data-stream-requires-token">Start/Stop Data Stream Requires Token</h5>
<p><em>Note: If you use the static <code>EyeTracking.GetGazePoint()</code> function you do not have to care about starting and stopping the data stream.</em></p>
<p>In the 2.0 framework we have changed the data stream functions for <code>Start</code> and <code>Stop</code> so that they now take a unique token. This was done to be able to handle the reference counting correctly in cases where the methods were not called symmetrically by client scripts which could lead to the data stream getting shutdown prematurely though there were other clients still requesting data (seems to happen when <code>Start</code> placed in <code>OnEnable</code> and <code>Stop</code> placed in <code>OnDisable</code> and <code>OnDisable</code> gets called an extra time maybe from <code>OnDestroy</code>).</p>
<p>From a MonoBehaviour script the game object&#39;s instance id can be used as a token:</p>
<pre><code>_gazePointDataProvider.Start(gameObject.GetInstanceID());
</code></pre><p>In a non-MonoBehaviour script, simply keep an empty game object as a private field and use its instance id:</p>
<pre><code>private GameObject _uniqueIdentifier = new GameObject(&quot;MyExampleClass_UniqueId&quot;);
...
_gazePointDataProvider.Start(_uniqueIdentifier.GetInstanceID());
</code></pre><h3 id="-eyetrackinghost-"><code>EyeTrackingHost</code></h3>
<p>The <code>EyeXHost</code> has been renamed <code>EyeTrackingHost</code>.</p>
<h4 id="use-eyetrackinghost-getinstance-to-access-eyetrackinghost-">Use <code>EyeTrackingHost.GetInstance()</code> to access <code>EyeTrackingHost</code></h4>
<p>In previous versions of the framework it has been recommended to keep a reference to the <code>EyeXHost</code> returned by <code>EyeXHost.GetInstance()</code>. In 2.0 the recommendation is the opposite, the <code>EyeTrackingHost</code> should always be accessed using <code>EyeTrackingHost.GetInstance()</code> and no reference should be kept in client scripts.</p>
<p>Why? In 2.0 we have introduced an interface <code>IEyeTrackingHost</code> for the <code>EyeTrackingHost</code> and the <code>EyeTrackingHost.GetInstance()</code> method returns different implementations of <code>IEyeTrackingHost</code> depending on from where in the application life cycle the method is called, making sure we have consistent behavior and that no memory is leaked during application shutdown (<code>OnApplicationQuit</code>, <code>OnDisable</code>, and <code>OnDestroy</code>) no matter which order the game objects are destroyed. This underlying structure is also used to return a stub version of the host when building for Linux and Mac.</p>
<h3 id="compiles-for-pc-mac-linux-standalone">Compiles for PC, Mac &amp; Linux Standalone</h3>
<p>EyeX Framework 2.0 can only provide eye-gaze data and interaction functionality on the Windows platform, but the framework compiles for both Linux and Mac target platforms. On these unsupported platforms the framework provides a stubbed implementation where all data points are marked as <code>Invalid</code> and the <code>EyeTrackingHost.TobiiEngineAvailability</code> property returns <code>EngineAvailability.NotAvailable</code>.</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
